# ECONNRESET 错误修复完整指南

## 问题总结

你遇到的错误：`uploadFile:fail Error: read ECONNRESET`

**根本原因**：后端服务在接收/处理文件上传时主动断开了连接。常见的原因有 5 个：
1. 后端服务没有启动
2. 文件大小限制太严格（原本只有 5MB）
3. 请求超时时间设置太短
4. 内存不足（使用内存存储大文件）
5. 中间件错误处理不当

---

## 修复清单

### ✅ 后端修复（server.js）

#### 修复 1：改用磁盘存储而不是内存存储
**为什么？**
- 原始方案：`multer.memoryStorage()` 会把所有上传的文件加载到内存
- 问题：如果文件很大，内存不足就会失败
- 解决：改用 `diskStorage()` 把文件先保存到磁盘

```javascript
// 之前（内存存储）
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 5 * 1024 * 1024 }  // 只有 5MB
})

// 之后（磁盘存储）
const upload = multer({
  storage: multer.diskStorage({...}),
  limits: { fileSize: 50 * 1024 * 1024 }  // 50MB
})
```

#### 修复 2：增加文件大小限制
- 原始：5MB（太小，很多音频都超过这个大小）
- 改为：50MB（更合理的限制）

#### 修复 3：添加请求超时配置
```javascript
// 全局超时配置
app.use((req, res, next) => {
  req.setTimeout(600000)  // 10 分钟
  res.setTimeout(600000)
  next()
})

// 单个请求超时
app.post('/api/audio-to-text', upload.single('audio'), async (req, res) => {
  req.setTimeout(300000)  // 这个请求 5 分钟超时
  ...
})
```

**为什么？**
- 默认 Express 超时是 120 秒（2 分钟）
- 如果音频文件大或网络慢，2 分钟不够
- 改为 5-10 分钟，给足够的时间完成上传和转码

#### 修复 4：改进文件读取方式
- 原始：`req.file.buffer`（内存中的 Buffer）
- 改为：`req.file.path`（磁盘文件路径）然后读取

**为什么？**
- 避免大文件全部在内存中转来转去
- 更高效，不容易出现内存溢出

---

### ✅ 前端修复（request.js）

#### 修复 1：添加重试机制
```javascript
function uploadAudio(audioPath, retries = 2) {
  // 如果遇到 ECONNRESET，自动重试 2 次
  // 每次重试间隔 2 秒
}
```

**为什么？**
- 网络不稳定时偶尔会失败
- 自动重试可以提高成功率
- 用户不用手动点击重新上传

#### 修复 2：添加更详细的错误诊断
```javascript
// 检查不同的错误类型
if (err.errMsg.includes('ECONNRESET')) {
  // 连接重置 - 重试
} else if (res.statusCode === 413) {
  // 文件太大 - 提示用户
} else {
  // 其他错误 - 直接返回
}
```

#### 修复 3：增加超时时间
- 添加 `timeout: 300000`（5 分钟）到上传请求

---

## 现在怎么办：操作步骤

### 步骤 1️⃣：停止旧的后端进程

如果有正在运行的后端，先停止它：
```bash
# Windows：按 Ctrl+C 停止进程
# 或者从任务管理器中杀死 node.exe 进程
```

### 步骤 2️⃣：启动后端服务

进入后端目录，设置端口并启动：

```bash
cd D:\projects\tools-1\audio-to-text-backend

# Windows 设置环境变量的方式
set PORT=9001
npm start
```

**重要：仔细查看输出！** 应该看到这样的信息：

```
========================================
🚀 音频转文字服务器已启动
📍 监听地址: http://localhost:9001
🎤 音频编码: M4A → WAV (16kHz, 单声道)
🤖 识别引擎: 腾讯云 ASR
========================================

✅ 可用的API端点：
   GET  http://localhost:9001/health
   POST http://localhost:9001/api/audio-to-text (真实识别)
   POST http://localhost:9001/api/audio-to-text-mock (模拟识别)
```

如果看到**错误信息**，说明有配置问题。常见错误：

| 错误信息 | 原因 | 解决办法 |
|---------|------|--------|
| `Error: EADDRINUSE` | 端口被占用 | 改用其他端口，如 `set PORT=9002` |
| `Error: SecretId not found` | 腾讯云密钥未配置 | 在 `.env` 文件中配置 `TENCENT_SECRET_ID` 和 `TENCENT_SECRET_KEY` |
| `Cannot find module 'xxxx'` | 依赖未安装 | 运行 `npm install` |

### 步骤 3️⃣：验证后端是否正常

```bash
# 在另一个终端中测试
curl http://localhost:9001/health

# 应该返回：
# {"code":0,"message":"Server is running","timestamp":"2024-12-22T..."}
```

### 步骤 4️⃣：在小程序中测试上传

1. 打开微信开发者工具
2. 预览小程序（或在开发工具中运行）
3. 录制音频
4. 点击"识别文字"按钮

**查看控制台输出**（开发者工具的 Console 或 Network 标签）：
- 应该看到 `[上传] 第 1 次尝试...`
- 然后 `[上传] 成功，TaskId: xxx`

---

## 修复前后对比

### 修复前的行为
```
1. 用户点击"识别"
2. 开始上传音频文件
3. 后端接收到文件头后，因为各种原因断开连接
4. 小程序收到 ECONNRESET 错误
5. 用户看到"上传失败"
6. 无法重试，只能重新录音
```

### 修复后的行为
```
1. 用户点击"识别"
2. 开始上传音频文件（支持更大的文件，超时时间更长）
3. 后端正确接收文件，保存到磁盘
4. 后端转码并调用腾讯云API
5. 如果中途出错，前端自动重试（最多 2 次）
6. 最终成功上传，返回任务ID
7. 前端轮询查询结果，显示识别文字
```

---

## 常见问题排查

### Q1: 为什么还是 ECONNRESET？

检查清单：
- [ ] 后端是否真的在 9001 端口运行？（用 curl 测试）
- [ ] 小程序中的 `apiBaseUrl` 是否正确？（检查 app.js 第 20 行）
- [ ] 是否修改了所有的代码文件？（检查 server.js 和 request.js）
- [ ] Windows 防火墙是否阻止了连接？（试试关闭防火墙测试）

### Q2: 为什么上传很慢？

原因可能有：
- 音频文件太大（> 50MB）
- 网络不稳定
- 后端转码耗时太长

解决：
- 检查音频文件大小（应该 < 10MB）
- 查看后端控制台的日志，确认每一步耗时
- 优化后端的转码配置

### Q3: 如何查看详细的错误日志？

后端日志在控制台中，看这些标记：
- `✅` = 成功
- `❌` = 失败
- `📥` = 接收文件
- `🔄` = 处理中
- `🌐` = 调用外部API

前端日志在微信开发者工具的 Console 中，看这些标记：
- `[上传]` = 上传相关
- `[轮询]` = 查询状态相关

---

## 总结

这个修复的核心理念是：

| 问题 | 解决方案 | 原理 |
|------|--------|------|
| 文件太大被拒绝 | 用磁盘存储 + 增加限制到 50MB | 不用内存，磁盘存储容量大 |
| 请求中途断开 | 增加超时时间到 5-10 分钟 | 给充足的时间完成操作 |
| 一次失败就放弃 | 前端自动重试 2 次 | 网络不稳定时可以恢复 |
| 错误难以诊断 | 加详细的日志和错误处理 | 能快速定位问题 |

现在你的系统应该能稳定地上传和识别音频了！

---

**最后的提示**：如果还有问题，请在后端控制台和前端开发者工具中 **截图错误信息** 给我，这样更容易诊断。
